# Standard Security Checks (Map-based)
# Automatically handles Danger hits, Rate Limits, and CIDR blocks

# 0. Break infinite mirroring loops (Safety)
if ($http_x_internal_mirror = "yes") {
    return 200 "ok";
}

# 1. CIDR/IP Restrictions (Blocked via map or rules)
# This is usually handled by the 'include ip-restrictions.conf' later, 
# but we can also trigger a violation here if needed.

# 2. Path/UA/Method Security Probes (Danger hits)
if ($security_violation_reason) {
    return 403;
}
if ($ua_violation_reason) {
    return 403;
}

# Handle 403 Forbidden (mirrors both explicit probes and upstream 403s)
error_page 403 @danger_handler;

location @danger_handler {
    internal;
    set $expected_status 403;
    
    # Priority: Map-based reasons, then UA, then generic
    set $violation_reason $security_violation_reason;
    if ($violation_reason = "") {
        set $violation_reason $ua_violation_reason;
    }
    if ($violation_reason = "") {
        set $violation_reason "forbidden";
    }

    mirror /_security_mirror;
    return 403;
}

# 3. Rate Limiting (Burst hits)
# Note: Nginx limit_req is handled via error_page 429
error_page 429 = @burst_handler;

location @burst_handler {
    internal;
    set $expected_status 429;
    set $violation_reason "rate_limit_exceeded";
    mirror /_security_mirror;
    return 429;
}

# CIDR Block Handler (triggered by deny/allow rules)
location @cidr_block {
    internal;
    set $expected_status 444; 
    set $violation_reason "cidr_blocked";
    mirror /_security_mirror;
    return 444;
}

# 4. Client Errors (4xx) - Intercepted from upstreams
error_page 400 401 404 405 408 413 414 431 451 @client_error_handler;

location @client_error_handler {
    internal;
    # Note: $status might be unstable here, but it is the best we have for generic capture
    set $expected_status $status;
    set $violation_reason "client_error";
    mirror /_security_mirror;
    return $status;
}
