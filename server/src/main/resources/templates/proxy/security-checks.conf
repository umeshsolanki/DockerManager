# Standard Security Checks (Map-based)
# Automatically handles Danger hits, Rate Limits, and CIDR blocks

# 0. Break infinite mirroring loops (Safety)
if ($http_x_internal_mirror = "yes") {
    return 200 "ok";
}

# 1. CIDR/IP Restrictions (Blocked via map or rules)
# This is usually handled by the 'include ip-restrictions.conf' later, 
# but we can also trigger a violation here if needed.

# 2. Path/UA/Method Security Probes (Danger hits)
if ($security_violation_reason) {
    return 403;
}
if ($ua_violation = "1") {
    return 403;
}

# Handle 403 Forbidden (mirrors both explicit probes and upstream 403s)
error_page 403 @danger_handler;

location @danger_handler {
    internal;
    set $expected_status 403;
    
    # Use specific reason if from map, otherwise generic
    set $violation_reason $security_violation_reason;
    if ($violation_reason = "") {
        set $violation_reason "forbidden";
    }

    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 403;
}

# 3. Rate Limiting (Burst hits)
# Note: Nginx limit_req is handled via error_page 429
error_page 429 @burst_handler;

location @burst_handler {
    internal;
    set $expected_status 429;
    set $violation_reason "rate_limit_exceeded";
    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 429;
}

# CIDR Block Handler (triggered by deny/allow rules)
location @cidr_block {
    internal;
    set $expected_status 444; 
    set $violation_reason "cidr_blocked";
    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 444;
}

# 4. Client Errors (4xx) - Intercepted from upstreams
# Enable interception to mirror upstream 4xx errors
proxy_intercept_errors on;
# NOTE: 400, 408, 413, 414, 431 are excluded because they can occur before the 
# URI is fully parsed, which causes "empty URI in redirect to named location" 
# errors when using named location handlers like @client_error_handler.
# 404 is excluded to avoid cluttering security logs with standard page-not-found errors.
error_page 401 405 451 @client_error_handler;

location @client_error_handler {
    internal;
    # Use the status that triggered the error page if available
    set $expected_status $status;
    if ($expected_status = "") {
        set $expected_status 400;
    }
    set $violation_reason "client_error";
    ${securityLoggingDirectives}
    mirror /_security_mirror;
    # Nginx return directive does not support variables for the status code.
    # Since we are using OpenResty, we use Lua to return the original status.
    content_by_lua_block {
        ngx.exit(tonumber(ngx.var.status) or 400)
    }
}
