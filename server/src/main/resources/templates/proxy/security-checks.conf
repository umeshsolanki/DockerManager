# Standard Security Checks (Map-based)
# Automatically handles Danger hits, Rate Limits, and CIDR blocks

# 0. Break infinite mirroring loops (Safety)
if ($http_x_internal_mirror = "yes") {
    return 200 "ok";
}

# 1. CIDR/IP Restrictions (Blocked via map or rules)
# This is usually handled by the 'include ip-restrictions.conf' later, 
# but we can also trigger a violation here if needed.

# 2. Path/UA/Method Security Probes (Danger hits)
if ($security_violation_reason) {
    return 403;
}
if ($ua_violation = "1") {
    return 403;
}

# Handle 403 Forbidden (mirrors both explicit probes and upstream 403s)
error_page 403 @danger_handler;

location @danger_handler {
    internal;
    set $expected_status 403;
    
    # Use specific reason if from map, otherwise generic
    set $violation_reason $security_violation_reason;
    if ($violation_reason = "") {
        set $violation_reason "forbidden";
    }

    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 403;
}

# 3. Rate Limiting (Burst hits)
# Note: Nginx limit_req is handled via error_page 429
${globalBurstLimit}

error_page 429 @burst_handler;

location @burst_handler {
    internal;
    set $expected_status 429;
    set $violation_reason "rate_limit_exceeded";
    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 429;
}

# CIDR Block Handler (triggered by deny/allow rules)
location @cidr_block {
    internal;
    set $expected_status 444; 
    set $violation_reason "cidr_blocked";
    ${securityLoggingDirectives}
    mirror /_security_mirror;
    return 444;
}

# 4. Client Errors (4xx) & Server Errors (5xx) - Intercepted from upstreams
# Enable interception to mirror upstream errors
proxy_intercept_errors on;

# Comprehensive error mirroring
# 444 is excluded as it's a non-standard "no response" code we use for drops.
error_page 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 421 422 423 424 425 426 428 429 431 451 @error_mirror_handler;
error_page 500 501 502 503 504 505 506 507 508 510 511 @error_mirror_handler;

location @error_mirror_handler {
    internal;
    # Use the status that triggered the error page
    set $expected_status $status;
    
    # Fallback if status is lost (shouldn't happen in error_page)
    if ($expected_status = "") {
        set $expected_status 500;
    }
    
    # Determine reason based on status code range
    set $violation_reason "client_error";
    if ($expected_status ~ "^5") {
        set $violation_reason "server_error";
    }

    ${securityLoggingDirectives}
    mirror /_security_mirror;
    
    # Return original status
    content_by_lua_block {
        ngx.exit(tonumber(ngx.var.status) or 500)
    }
}
