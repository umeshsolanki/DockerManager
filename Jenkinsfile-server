def VERSION = ""

pipeline {
    agent any

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Extract version from server's build.gradle.kts
                    VERSION = sh(script: "./gradlew :server:properties -q | grep '^version:' | awk '{print \$2}'", returnStdout: true).trim()
                    echo "Building Version: ${VERSION}"

                    // Change Detection Logic
                    def relevantChanges = false
                    // If changeset is empty, it might be a manual run or first run -> Force Build
                    if (currentBuild.changeSets.isEmpty()) {
                        echo "No changesets detected (manual run or first run). Forcing build."
                        relevantChanges = true
                    } else {
                        def patterns = ["server/", "web-app/", ".gradle.kts", "Jenkinsfile-server"]
                        echo "Checking for changes in: ${patterns}"
                        
                        // Check all changed files
                        // Check all changed files
                        for (def changeSet in currentBuild.changeSets) {
                            if (relevantChanges) break
                            for (def entry in changeSet.items) {
                                if (relevantChanges) break
                                for (def path in entry.affectedPaths) {
                                    if (relevantChanges) break
                                    for (def pattern in patterns) {
                                        if (path.contains(pattern)) {
                                            echo "Relevant change detected: ${path}"
                                            relevantChanges = true
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (relevantChanges) {
                        env.SHOULD_BUILD = "true"
                        echo "Proceeding with build."
                    } else {
                        env.SHOULD_BUILD = "false"
                        echo "No relevant changes found. Skipping subsequent build stages."
                        currentBuild.result = 'SUCCESS'
                    }
                }
            }
        }

        stage('Test') {
            when {
                expression { return env.SHOULD_BUILD == 'true' }
            }
            steps {
                // Run unit tests for server module with build cache
                sh './gradlew :server:test --build-cache'
            }
        }

        stage('Build Web UI') {
            when {
                expression { return env.SHOULD_BUILD == 'true' }
            }
            steps {
                script {
                    docker.image('node:20-alpine').inside {
                        dir('web-app') {
                            // Use npm ci for faster, reliable builds and cache node_modules
                            sh 'npm ci --prefer-offline --no-audit'
                            sh 'npm run build'
                        }
                    }
                    // Create directory for static resources in server module
                    sh 'mkdir -p server/src/main/resources/ui'
                    // Clear existing resources if any
                    sh 'rm -rf server/src/main/resources/ui/*'
                    // Copy built UI to server resources
                    sh 'cp -r web-app/out/* server/src/main/resources/ui/'
                }
            }
        }

        stage('Build FatJar') {
            when {
                expression { return env.SHOULD_BUILD == 'true' }
            }
            steps {
                // Use shadowJar task to build the FatJar with build cache
                sh './gradlew :server:shadowJar --build-cache'
            }
        }

        stage('Deploy Server (Systemd)') {
            when {
                expression { return env.SHOULD_BUILD == 'true' }
            }
            environment {
                BUILD_NUMBER = "${VERSION}"
            }
            steps {
                // Copy the built jar to /opt/docker-manager
                sh 'mkdir -p /opt/docker-manager'
                sh 'cp -f server/build/libs/server-all.jar /opt/docker-manager/server-all.jar'
                
                // Copy service files
                sh 'cp docker-manager.service /opt/docker-manager/docker-manager.service'
                sh 'cp docker-manager.path /opt/docker-manager/docker-manager.path'
                sh 'cp docker-manager-restart.service /opt/docker-manager/docker-manager-restart.service'
                sh 'cp setup-services.sh /opt/docker-manager/setup-services.sh'
                
                // Run setup script
               // sh 'chmod +x /opt/docker-manager/setup-services.sh'
               // sh '/opt/docker-manager/setup-services.sh'
                
                // Start/Restart the service
               // sh 'systemctl restart docker-manager.service'
            }
        }
    }
    
    post {
        always {
            script {
                // Cleanup old containers and images from previous builds
                sh "docker ps -a --filter 'label=jenkins_build_id' --format '{{.ID}}' | xargs -r docker inspect --format '{{.Id}} {{index .Config.Labels \"jenkins_build_id\"}}' | grep -v '${env.BUILD_ID}' | awk '{print \$1}' | xargs -r docker rm -f || true"
                sh "docker images --filter 'label=jenkins_build_id' --format '{{.ID}}' | xargs -r docker inspect --format '{{.Id}} {{index .Config.Labels \"jenkins_build_id\"}}' | grep -v '${env.BUILD_ID}' | awk '{print \$1}' | xargs -r docker rmi -f || true"
            }
            cleanWs()
        }
    }
}
